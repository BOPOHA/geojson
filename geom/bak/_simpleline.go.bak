package geom

type simpleLine struct {
	points []Point
}

func newSimpleLine(points []Point) *simpleLine {
	line := new(simpleLine)
	line.points = make([]Point, len(points))
	copy(line.points, points)
	return line
}

func (line *simpleLine) Rect() Rect {
	return pointsRect(line.points)
}

func (line *simpleLine) Convex() bool {
	return pointsConvex(line.points)
}

func (line *simpleLine) Points() []Point {
	return line.points
}

func (line *simpleLine) IsClosed() bool {
	return false
}

func (line *simpleLine) Scan(iter func(seg Segment) bool) {
	if len(line.points) == 1 {
		iter(Segment{A: line.points[0], B: line.points[0]})
	} else {
		for i := 0; i < len(line.points)-1; i++ {
			if !iter(Segment{A: line.points[i], B: line.points[i+1]}) {
				return
			}
		}
	}
}
func (line *simpleLine) Search(
	rect Rect, iter func(seg Segment, index int) bool,
) {
	var index int
	line.Scan(func(seg Segment) bool {
		if seg.Rect().IntersectsRect(rect) {
			if !iter(seg, index) {
				return false
			}
		}
		index++
		return true
	})
}

func (line *simpleLine) ContainsPoint(point Point, allowOnEdge bool) bool {
	if !allowOnEdge {
		return false
	}
	var contains bool
	line.Search(Rect{point, point}, func(seg Segment, index int) bool {
		if raycast(point, seg.A, seg.B).on {
			contains = true
			return false
		}
		return true
	})
	return contains
}
