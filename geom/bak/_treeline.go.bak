package geom

import "github.com/tidwall/boxtree/d2"

type treeLine struct {
	points []Point
	rect   Rect
	convex bool
	tree   d2.BoxTree
}

func newTreeLine(points []Point) *treeLine {
	line := new(treeLine)
	line.points = make([]Point, len(points))
	copy(line.points, points)
	line.init()
	return line
}

func (line *treeLine) init() {
	line.convex, line.rect = pointsConvexRect(line.points)
	addSegToIndex := func(seg Segment, index int) {
		rect := seg.Rect()
		line.tree.Insert(
			[]float64{rect.Min.X, rect.Min.Y},
			[]float64{rect.Max.X, rect.Max.Y},
			index,
		)
	}
	if len(line.points) == 1 {
		addSegToIndex(Segment{A: line.points[0], B: line.points[0]}, 0)
	} else {
		for i := 0; i < len(line.points)-1; i++ {
			addSegToIndex(Segment{A: line.points[i], B: line.points[i+1]}, i)
		}
	}
}

func (line *treeLine) Rect() Rect {
	return line.rect
}

func (line *treeLine) Convex() bool {
	return line.convex
}

func (line *treeLine) Points() []Point {
	return line.points
}

func (line *treeLine) IsClosed() bool {
	return false
}

func (line *treeLine) Scan(iter func(seg Segment) bool) {
	if len(line.points) == 1 {
		iter(Segment{A: line.points[0], B: line.points[0]})
	} else {
		for i := 0; i < len(line.points)-1; i++ {
			if !iter(Segment{A: line.points[i], B: line.points[i+1]}) {
				return
			}
		}
	}
}

func (line *treeLine) Search(
	rect Rect, iter func(seg Segment, index int) bool,
) {
	line.tree.Search(
		[]float64{rect.Min.X, rect.Min.Y},
		[]float64{rect.Max.X, rect.Max.Y},
		func(_, _ []float64, value interface{}) bool {
			index := value.(int)
			var seg Segment
			if index == 0 && len(line.points) == 1 {
				seg = Segment{A: line.points[0], B: line.points[0]}
			} else {
				seg = Segment{A: line.points[index], B: line.points[index+1]}
			}
			if !iter(seg, index) {
				return false
			}
			return true
		},
	)
}

func (line *treeLine) ContainsPoint(point Point, allowOnEdge bool) bool {
	if !allowOnEdge {
		return false
	}
	var contains bool
	line.Search(Rect{point, point}, func(seg Segment, index int) bool {
		if raycast(point, seg.A, seg.B).on {
			contains = true
			return false
		}
		return true
	})
	return contains
}
